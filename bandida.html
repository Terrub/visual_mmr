<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <title>Bandida tiles</title>

    <script src="utils.js"></script>
    <script src="display.js"></script>
    <script src="mainLoop.js"></script>
    <script src="bandidaTiles.js"></script>
    <script src="solveGivenTileSet.js"></script>

    <style type="text/css">
      html {
        padding: 0;
        margin: 0;
        width: 100%;
        height: 100%;
      }

      body {
        color: white;
        margin: 0;
        padding: 0;
        background-color: black;
        width: 100%;
        height: 100%;
      }

      canvas {
        /* background-color: #161616; */
        position: absolute;
        z-index: -1;
      }

      button,
      input {
        width: 5em;
        height: 2em;
        border-radius: 0px;
        padding: 0.35em;
        text-align: center;
        opacity: 50%;
      }

      div.scoreBoard {
        position: fixed;
      }

      label {
        font-family: Arial, Helvetica, sans-serif;
      }

      span {
        color: rgb(120, 200, 0);
      }

      input {
        padding: 0;
      }

      input:invalid {
        border: 1px solid red;
      }

      input:valid {
        border: 1px solid green;
      }
    </style>
  </head>
  <body>
    <script type="text/javascript">
      let boardCanvas;
      let boardDisplay;

      let placedTilesCanvas;
      let placedTilesDisplay;

      let hudCanvas;
      let hudDisplay;

      let grid;
      let loop;
      let tileSet;
      let scale = 10;
      let boardWidth = 50;
      let boardHeight = 50;

      function createCanvas(width, height) {
        const canvas = document.createElement("canvas");

        canvas.width = width;
        canvas.height = height;

        return canvas;
      }

      function displayGameOver() {
        const gameStateTextElem = document.getElementById("gameStateText");
        gameStateTextElem.style.setProperty("color", "red");
        gameStateTextElem.innerText = "GAME OVER!";
      }

      function displayGameWon() {
        const gameStateTextElem = document.getElementById("gameStateText");
        gameStateTextElem.style.setProperty("color", "green");
        gameStateTextElem.innerText = "GAME WON";
      }

      function updateScoreBoard(value) {
        document.getElementById("boardValue").innerText = value;
      }

      function updateNumIterations(value) {
        document.getElementById("numIterations").innerText = value;
      }

      function renderTile(display, tile, tileX, tileY, rotation, scale) {
        // TODO: Pass display as dependancy
        // TODO: Leave tile coords up to caller

        /*
                  We could have a tile display marked as:

                  # . #      # . # # # #
                  # . .  or  . . . . . .
                  # . #      # # # # . #
                  # . #
                  . . #
                  # . #

                  So We have 18 cells of 3 x 6 with either empty or filled cells
                  and we have a rotation possible

                  we'd also have to take into account a minor margin so we can distinguish cells from one tile
                  to the tile next to it.
              */
        const x_lim = 2;
        const y_lim = 5;

        for (const cell of tile.cells) {
          let x = 0;
          let y = 0;
          let w = scale;
          let h = scale;

          if (rotation === 0) {
            x = cell.x * scale + tileX;
            y = cell.y * scale + tileY;
          } else if (rotation === 1) {
            x = (y_lim - cell.y) * scale + tileX;
            y = cell.x * scale + tileY;
          } else if (rotation === 2) {
            x = (x_lim - cell.x) * scale + tileX;
            y = (y_lim - cell.y) * scale + tileY;
          } else if (rotation === 3) {
            x = cell.y * scale + tileX;
            y = (x_lim - cell.x) * scale + tileY;
          }

          display.drawRect(x, y, w, h, cell.type);
        }

        display.strokeRect(
          tileX + 1,
          tileY + 1,
          (3 + (rotation % 2) * 3) * scale - 2,
          (3 + ((rotation + 1) % 2) * 3) * scale - 2,
          "000",
          2
        );
      }

      function renderBoard() {
        const bW = boardWidth * 3 * scale;
        const bH = boardHeight * 3 * scale;
        boardDisplay.drawRect(0, 0, bW, bH, "#222");

        const maxCells = boardWidth * boardHeight;
        const gridSize = 3 * scale;
        // for (let i = 0; i < maxCells; i += gridSize) {
        //     const x = i % bW;
        //     const y = Math.floor(i / bW) * gridSize;
        //     boardDisplay.strokeRect(x, y, gridSize, gridSize, "#FFF", 2);
        // }
        // Horizontal grid lines
        for (let i = 0; i <= bH; i += gridSize) {
            boardDisplay.drawLine(0, i, bW, i, "#111", 2);
        }

        // Vertical grid lines
        for (let i = 0; i <= bW; i += gridSize) {
            boardDisplay.drawLine(i, 0, i, bH, "#111", 2);
        }
      }

      function renderPlacedTiles(tiles) {
        placedTilesDisplay.clear();

        for (const tile of tiles) {
          if (isDefined(tile)) {
            const tileX = tile.x * 3 * scale;
            const tileY = tile.y * 3 * scale;
            renderTile(
              placedTilesDisplay,
              tile,
              tileX,
              tileY,
              tile.rotation,
              scale
            );
          }
        }
      }

      function renderHUD(hand, tiles) {
        hudDisplay.clear();
        const localScale = scale + Math.floor(scale / 2);

        for (let i = 0; i < hand.length; i += 1) {
          const tile = hand[i];
          const x = i * 3 * (localScale + 1) + 5;
          const y = 30;
          renderTile(hudDisplay, tile, x, y, 0, localScale);
        }

        for (let i = 0; i < tiles.length; i += 1) {
          const tile = tiles[i];
          const x = 5;
          const y = window.innerHeight - i * 5 - 3 * localScale - 5;
          renderTile(hudDisplay, tile, x, y, 3, localScale);
        }
      }

      function createGrid(maxWidth, maxHeight) {
        let centreTilePlaced = false;
        const proto_grid = {};
        const tiles = [];
        const spots = [];

        const NORTH = 2;
        const EAST = 4;
        const SOUTH = 8;
        const WEST = 1;

        const checkSpots = [
          [NORTH, 0, -1, SOUTH],
          [EAST, 1, 0, WEST],
          [SOUTH, 0, 1, NORTH],
          [WEST, -1, 0, EAST],
        ];

        for (let i = 0; i < maxHeight; i += 1) {
          spots.push(new Array(maxWidth).fill(undefined));
        }

        function spotAvailable(x, y) {
          if (x < 0 || x >= maxWidth || y < 0 || y >= maxHeight) {
            return false;
          }
          return spots[y][x] === undefined;
        }

        function updateSpotsForRotation(tile, x, y, rotation) {
          const rotationData = [
            // Rotation 0
            {
              head: {
                xOffset: 0,
                yOffset: 0,
                indices: [
                  [0, WEST],
                  [1, NORTH],
                  [2, EAST],
                ],
              },
              tail: {
                xOffset: 0,
                yOffset: 1,
                indices: [
                  [3, EAST],
                  [4, SOUTH],
                  [5, WEST],
                ],
              },
            },
            // Rotation 1
            {
              head: {
                xOffset: 0,
                yOffset: 0,
                indices: [
                  [3, SOUTH],
                  [4, WEST],
                  [5, NORTH],
                ],
              },
              tail: {
                xOffset: 1,
                yOffset: 0,
                indices: [
                  [0, NORTH],
                  [1, EAST],
                  [2, SOUTH],
                ],
              },
            },
            // Rotation 2
            {
              head: {
                xOffset: 0,
                yOffset: 0,
                indices: [
                  [3, WEST],
                  [4, NORTH],
                  [5, EAST],
                ],
              },
              tail: {
                xOffset: 0,
                yOffset: 1,
                indices: [
                  [0, EAST],
                  [1, SOUTH],
                  [2, WEST],
                ],
              },
            },
            // Rotation 3
            {
              head: {
                xOffset: 0,
                yOffset: 0,
                indices: [
                  [0, SOUTH],
                  [1, WEST],
                  [2, NORTH],
                ],
              },
              tail: {
                xOffset: 1,
                yOffset: 0,
                indices: [
                  [3, NORTH],
                  [4, EAST],
                  [5, SOUTH],
                ],
              },
            },
          ];

          const curRotation = rotationData[rotation];
          for (const sectionName in curRotation) {
            const section = curRotation[sectionName];
            let spotValue = 0;
            for (const row of section.indices) {
              if (tile.definition[row[0]] === "1") {
                spotValue += row[1];
              }
            }
            setSpotAt(spotValue, x + section.xOffset, y + section.yOffset);
          }
        }

        function removeSpotsForRotation(x, y, rotation) {
          const tailX = x + (rotation % 2);
          const tailY = y + 1 - (rotation % 2);
          removeSpotAt(x, y);
          removeSpotAt(tailX, tailY);
        }

        function placeTileAt(tile, x, y, rotation) {
          if (isOutOfBounds(x, y, rotation)) {
            return false;
          }

          const tailX = x + (rotation % 2);
          const tailY = y + 1 - (rotation % 2);

          tile.x = x;
          tile.y = y;
          tile.rotation = rotation;

          // Set tile at head location
          const headIndex = y * maxWidth + x;
          tiles[headIndex] = tile;

          // set tile at tail location
          const tailIndex = tailY * maxWidth + tailX;
          tiles[tailIndex] = tile;

          updateSpotsForRotation(tile, x, y, rotation);

          //   console.table(spots);
          return true;
        }

        function removeTileAt(x, y, rotation) {
          if (isUndefined(getTileAt(x, y))) {
            return;
          }

          // Unset tile at head location
          const headIndex = y * maxWidth + x;
          tiles[headIndex] = undefined;

          // Unset tile at tail location
          const tailX = x + (rotation % 2);
          const tailY = y + 1 - (rotation % 2);
          const tailIndex = tailY * maxWidth + tailX;
          tiles[tailIndex] = undefined;

          // Unset spots too
          removeSpotAt(x, y);
          removeSpotAt(tailX, tailY);
        }

        function getTileAt(x, y) {
          // TODO: Check if index out of bounds.
          return tiles[y * maxWidth + x];
        }

        function setSpotAt(value, x, y) {
          spots[y][x] = value;
        }

        function removeSpotAt(x, y) {
          spots[y][x] = undefined;
        }

        function getSpotAt(x, y) {
          if (x < 0 || x >= maxWidth) {
            return;
          }

          if (y < 0 || y >= maxHeight) {
            return;
          }

          return spots[y][x];
        }

        function getMatchStringForSpot(cX, cY) {
          let matchString = "";
          for (const checkSpot of checkSpots) {
            const tX = cX + checkSpot[1];
            const tY = cY + checkSpot[2];
            const targetSpot = getSpotAt(tX, tY);
            if (isDefined(targetSpot)) {
              matchString += (targetSpot & checkSpot[3]) / checkSpot[3];
            } else {
              matchString += "a";
            }
          }

          return matchString;
        }

        function tileMatchesForRotation(matchStr, definition, rotation) {
          const matchIndices = [
            [
              // rotation 0
              [1, 3],
              [2, 4],
              [3, 5],
              [4, 1],
              [5, 2],
              [7, 0],
            ],
            [
              // rotation 1
              [2, 3],
              [3, 4],
              [0, 5],
              [4, 0],
              [5, 1],
              [6, 2],
            ],
            [
              // rotation 2
              [1, 0],
              [2, 1],
              [3, 2],
              [4, 4],
              [5, 5],
              [7, 3],
            ],
            [
              // rotation 3
              [2, 0],
              [3, 1],
              [0, 2],
              [4, 3],
              [5, 4],
              [6, 5],
            ],
          ];

          for (const indices of matchIndices[rotation]) {
            const value = matchStr[indices[0]];
            const marker = definition[indices[1]];
            if (value !== "a" && value !== marker) {
              return false;
            }
          }

          return true;
        }

        function isValidTilePlacement(tile, x, y, rotation) {
          // Temporarily set spot values:
          if (isOutOfBounds(x, y, rotation)) {
            return false;
          }

          updateSpotsForRotation(tile, x, y, rotation);

          const tailX = x + (rotation % 2);
          const tailY = y + 1 - (rotation % 2);
          const segments = [
            { vertical: SOUTH, horizontal: EAST, x: x, y: y }, // Head segment
            { vertical: NORTH, horizontal: WEST, x: tailX, y: tailY }, // Tail segment
          ];
          for (const segment of segments) {
            for (const checkSpot of checkSpots) {
              if (
                (rotation % 2 === 0 && checkSpot[0] === segment.vertical) ||
                (rotation % 2 === 1 && checkSpot[0] === segment.horizontal)
              ) {
                // Ignore our other segment
                continue;
              }
              const tX = segment.x + checkSpot[1];
              const tY = segment.y + checkSpot[2];
              if (
                isUndefined(getSpotAt(tX, tY)) &&
                isSquare(tX, tY) &&
                isDeathSquare(tX, tY)
              ) {
                // We've created a deathSquare.
                // Clean up
                removeSpotsForRotation(x, y, rotation);
                // And GTFO
                return false;
              }
            }
          }

          // Seems nothing wrong with this placement. we'll pack up and let you be.
          removeSpotsForRotation(x, y, rotation);

          return true;
        }

        function addAvailablePositionsForSpot(
          availPos,
          tile,
          cX,
          cY,
          mustConnect = true
        ) {
          if (isDefined(getSpotAt(cX, cY))) {
            // OCCUPADO!!
            return;
          }

          if (isIsolated(cX, cY)) {
            // No adjacent tiles. early exit.
            return;
          }

          if (isSquare(cX, cY)) {
            // No available space... early exit.
            return;
          }

          const matchString = getMatchStringForSpot(cX, cY);
          if (!matchString.includes("1") && mustConnect) {
            // No halls to connect to but we must, so not available.
            return;
          }

          const directions = {
            north: {
              checkIndex: 0,
              head: [0, -1],
              tail: [0, -1],
              rotations: [0, 2],
            },
            east: {
              checkIndex: 1,
              head: [0, 0],
              tail: [1, 0],
              rotations: [1, 3],
            },
            south: {
              checkIndex: 2,
              head: [0, 0],
              tail: [0, 1],
              rotations: [0, 2],
            },
            west: {
              checkIndex: 3,
              head: [-1, 0],
              tail: [-1, 0],
              rotations: [1, 3],
            },
          };

          for (const directionName in directions) {
            const direction = directions[directionName];
            if (matchString[direction.checkIndex] !== "a") {
              continue;
            }

            const tailMatchString = getMatchStringForSpot(
              cX + direction.tail[0],
              cY + direction.tail[1]
            );
            for (const rotation of direction.rotations) {
              let totalMatchStr;
              if (directionName === "north" || directionName === "east") {
                totalMatchStr = matchString + tailMatchString;
              } else {
                totalMatchStr = tailMatchString + matchString;
              }

              const pX = cX + direction.head[0];
              const pY = cY + direction.head[1];
              if (
                tileMatchesForRotation(
                  totalMatchStr,
                  tile.definition,
                  rotation
                ) &&
                isValidTilePlacement(tile, pX, pY, rotation)
              ) {
                availPos.push({
                  x: pX,
                  y: pY,
                  rotation: rotation,
                  totalMatchString: totalMatchStr,
                });
              }
            }
          }
        }

        function deltaFromCentre(x, y) {
          const centreX = Math.floor(maxWidth / 2);
          const centreY = Math.floor(maxHeight / 2);
          let delta = Math.abs(centreX - x);
          delta += Math.abs(centreY - y);

          return delta;
        }

        function isIsolated(x, y) {
          for (const checkSpot of checkSpots) {
            const tX = x + checkSpot[1];
            const tY = y + checkSpot[2];
            if (isDefined(getSpotAt(tX, tY))) {
              return false;
            }
          }

          return true;
        }

        function isOutOfBounds(x, y, rotation) {
          const tailX = x + (rotation % 2);
          const tailY = y + 1 - (rotation % 2);
          if (x < 0 || y < 0 || tailX > maxWidth - 1 || tailY > maxHeight - 1) {
            // console.log("Attemp at placing tile out of bounds");
            return true;
          }

          return false;
        }

        function isSquare(x, y) {
          for (const checkSpot of checkSpots) {
            const tX = x + checkSpot[1];
            const tY = y + checkSpot[2];
            if (isUndefined(getSpotAt(tX, tY))) {
              return false;
            }
          }

          return true;
        }

        function isDeathSquare(x, y) {
          for (const checkSpot of checkSpots) {
            const tX = x + checkSpot[1];
            const tY = y + checkSpot[2];
            if ((getSpotAt(tX, tY) & checkSpot[3]) === checkSpot[3]) {
              return true;
            }
          }

          return false;
        }

        function isFixableWithRemainingTiles(x, y) {
          for (const tile of tileSet) {
            const availPos = [];
            addAvailablePositionsForSpot(availPos, tile, x, y, false);
            if (availPos.length > 0) {
              // We found at least one tile that fits here!
              // TODO: Perhaps count number of available tiles.
              //      More available tiles = better?
              return true;
            }
          }

          // Seems no tiles will fit... invalid board now.
          return false;
        }

        proto_grid.isBoardFixable = () => {
          const numSpots = maxWidth * maxHeight;
          for (let index = 0; index < numSpots; index += 1) {
            const y = Math.floor(index / maxWidth);
            const x = index % maxWidth;
            // check if we have a square.
            if (isSquare(x, y)) {
              // Is it a deathsquare?
              if (isDeathSquare(x, y)) {
                // Yup, it's a deathsquare, you're Fkd...
                return false;
              }
            } else {
              // Not a square so we can still place tiles here.
              // But have we created a case that can only be fixed by a card we no longer have?
              if (!isFixableWithRemainingTiles(x, y)) {
                return false;
              }
            }
          }

          // Couldn't find anything wrong... yet.
          return true;
        };

        proto_grid.calculateBoardValue = () => {
          const numSpots = maxWidth * maxHeight;
          let boardValue = 0;
          for (let index = 0; index < numSpots; index += 1) {
            const y = Math.floor(index / maxWidth);
            const x = index % maxWidth;
            const currSpot = getSpotAt(x, y);
            if (isUndefined(currSpot)) {
              // empty spot,
              if (isIsolated(x, y)) {
                // Isolated spot, not worth checking out... NEXT!!!!
                continue;
              }
            }

            for (const checkSpot of checkSpots) {
              if ((currSpot & checkSpot[0]) === checkSpot[0]) {
                // We have an exit, check if it's occupied
                if (
                  isUndefined(getSpotAt(x + checkSpot[1], y + checkSpot[2]))
                ) {
                  // Not occupied, means open exit, is bad.
                  boardValue += 1;
                }
              }
            }
          }

          return boardValue;
        };

        proto_grid.placeTileAt = (tile, x, y, rotation) => {
          return placeTileAt(tile, x, y, rotation);
        };

        proto_grid.removeTileAt = (x, y, rotation) => {
          removeTileAt(x, y, rotation);
        };

        proto_grid.getTiles = () => {
          return tiles;
        };

        proto_grid.getAvailablePositions = (tile) => {
          const availablePositions = [];
          for (let cY = maxHeight - 1; cY >= 0; cY -= 1) {
            for (let cX = maxWidth - 1; cX >= 0; cX -= 1) {
              addAvailablePositionsForSpot(availablePositions, tile, cX, cY);
            }
          }

          // order available positions by distance from centre tile DESC.
          // (highest distance up front)
          availablePositions.sort((a, b) => {
            return deltaFromCentre(b.x, b.y) - deltaFromCentre(a.x, a.y);
          });

          return availablePositions;
        };

        proto_grid.placeCentreTile = (centreTile) => {
          if (centreTilePlaced) {
            throw new Error("Can only place centre tile once");
          }
          const x = Math.floor(maxWidth / 2);
          const y = Math.floor(maxHeight / 2);

          placeTileAt(centreTile, x, y, 1);
          centreTilePlaced = true;
        };

        return proto_grid;
      }

      function drawTiles(hand, n = 3) {
        while (hand.length < n) {
          /*
          const randomIndex = generateRandomNumber(tileSet.length);
          const tile = tileSet.splice(randomIndex, 1)[0];
          /*/
          const tile = tileSet.pop();
          //*/

          hand.push(tile);
        }
      }

      function init() {
        const cW = boardWidth * scale * 3;
        const cH = boardHeight * scale * 3;

        boardCanvas = createCanvas(cW, cH);
        document.body.appendChild(boardCanvas);
        boardDisplay = createDisplayFromCanvas(boardCanvas);

        placedTilesCanvas = createCanvas(cW, cH);
        document.body.appendChild(placedTilesCanvas);
        placedTilesDisplay = createDisplayFromCanvas(placedTilesCanvas);

        hudCanvas = createCanvas(window.innerWidth, window.innerHeight);
        hudCanvas.style.setProperty("position", "fixed");
        document.body.appendChild(hudCanvas);
        hudDisplay = createDisplayFromCanvas(hudCanvas);

        tileSet = AVAILABLE_TILES.slice();

        const centreTileIndex = tileSet.indexOf(TILE_BANDIDA);
        const centreTile = tileSet.splice(centreTileIndex, 1)[0];
        const grid = createGrid(boardWidth, boardHeight);
        const hand = [];
        const game = createGivenTileSetSolver(tileSet, grid);

        grid.placeCentreTile(centreTile);
        game.drawTiles(hand);

        renderBoard();

        let numIterations = 0;
        function tic() {
          // Update the board
          numIterations += 1;
          const boardValue = grid.calculateBoardValue();
          updateScoreBoard(boardValue);
          updateNumIterations(numIterations);

          // Do the gameplay loop itself
          // First we try and place a tile
          const gameState = game.placeTile(boardValue, hand);
          // Then we draw up to full
          game.drawTiles(hand);

          renderPlacedTiles(grid.getTiles());
          renderHUD(hand, tileSet);

          if (gameState === 0) {
            // Game completed successfully
            displayGameWon();
            loop.stop();
          }

          if (gameState === -1) {
            // Game over.
            displayGameOver();
            loop.stop();
          }
        }

        loop = mainLoop(tic);
        loop.start();
      }

      window.onload = init;
    </script>
    <div class="scoreBoard">
      <button id="btn_next" onclick="loop.next();">>>></button>
      <button id="btn_start" onclick="loop.start();">Start</button>
      <button id="btn_stop" onclick="loop.stop();">Stop</button>
      <label>
        Board value: <span id="boardValue">0</span> Iterations:
        <span id="numIterations">0</span>
        <span id="gameStateText"></span>
      </label>
    </div>
  </body>
</html>
